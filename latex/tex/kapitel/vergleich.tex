\chapter{Vergleich}

Das folgende Kapitel die drei besprochenen Entscheidungssysteme vergleichen. Der Vergleich wird sich auf die Implementierung und Performance fokussieren. Eine Implementierung wird bewertet auf die Punkte der Skalierbarkeit, Änderung und Architektur Komplexität. Der Performance Vergleich geschieht über Benchmark Tests, mit einem Fokus auf Frames Per Second (FPS) und Speicherverbrauch.

Mit der Skalierbarkeit ist die Erweiterung der Entscheidungssysteme gemeint. Eine Erweiterung passiert, wenn dem NPC neue Aktionen hinzufügt werden. Die Aktion muss dabei in das Entscheidungssystem mit ihren Komponenten und Zuständen integriert werden. Auch Änderungen einer Aktion kann zu Änderungen im Entscheidungssystemen führen. Die Erweiterung und Skalierung beansprucht Zeit. So wäre es im Vorteil, wenn das Entscheidungssystem hinsichtlich Skalierbarkeit und Änderung möglichst einfach ist. Dabei wäre es unter anderem im Vorteil, wenn die Funktionsweise möglichst einfach ist.

Bei Erweiterungen oder Änderungen von Aktionen muss das Entscheidungssystem auch getestet werden. Das Testen (Debuggen) prüft unter anderem die Spiellogik, Performance und Speicherverbrauch. Mit Spiellogik ist gemeint, dass ein NPC korrekte Aktionen im Sinne des Spielers ausführt. Beispielsweise macht es keinen Sinn, dass der NPC den Spieler im Nahkampf angreift, obwohl der Weg zum Spieler zu weit ist und der NPC die Möglichkeit hat sein Waffe zu benutzen. Das Testen kann je nach Entscheidungssystem unterschiedlich komplex und Zeit benötigen. Ein möglichst einfaches Nachvollziehen der Entscheidungen des Entscheidungssystem wäre dabei im Vorteil und variiert nach Entscheidungssystem. 

Auch die Implementation eines Entscheidungssystems wird bewertet. Die Entscheidungssysteme sind in ihrer Funktionsweise und Architektur unterschiedlich komplex. Die Funktionsweise und Architektur sollte bei einem Entscheidungssystem für den Entwickler möglichst nachvollziehbar sein. Eine möglichst simple Umsetzung wäre dabei im Vorteil, um Zeit zu sparen.

Über Benchmarks soll festgestellt werden, wie sich die Entscheidungssysteme hinsichtlich Performance und Speicherverbrauch unterscheiden. So wäre ein möglichst effizientes Entscheidungssystem im Vorteil und spiegelt sich im Videospiel wieder. Eine gute Performance und guter Speicherverbrauch ist im Vorteil für den Konsumenten und Entwickler. Bei einem effizienten Videospiel benötigt der Konsument keine teure Hardware und erhält ein flüssigeres Spielerlebnis, was wiederum für positive Wertungen führt. Somit hat auch der Entwickler einen Vorteil, da sein Videospiel durch die Wertung Aufmerksamkeit bekommt, was wiederum zu Käufen des Videospieles führen kann.

Die Ergebnisse werden anschließend anhand einer Tabelle zusammengefasst.

\section{Finite State Machine}

% Hinzufügen: Nach der Fertigstellung zeigen NPC mit FSM vorhersehbares Verhalten.

Die FSM ist schwer skalierbar. Wird eine Aktion (Knoten) geändert oder hinzugefügt, so muss der Graph der FSM angepasst werden. Eine Änderung oder das Hinzufügen einer Aktion kann dazu führen, dass andere Knoten die mit der Aktion in Verbindung stehen ebenfalls geändert werden müssen. Dies kann zu einem Dominoeffekt führen, bei der eine Kette an Knoten geändert werden muss und wiederum Zeitaufwand bedeutet. Zustände und Übergänge sollten dabei vollständig definiert sein, so dass der NPC nicht in falschen Zuständen hängen bleibt. Die FSM wird mit jeder Erweiterung an Aktionen auch unübersichtlicher. So hatte das Spiel Half-Life (1998) ca. 80 so genannte Tasks, welche alle einem Zustand zugewiesen sind.\autocite{U2023} Die Unübersichtlichkeit führt zur erhöhten Komplexität des Entscheidungssystems.

Das Debuggen einer FSM ist vergleichsweise einfach \autocite{review_game_ai}, da ihre Struktur statisch ist und sich nicht dynamisch verändert. Durch die Visualisierung des Graphen lässt sich nachvollziehen, welche Knoten zur ausgeführten Aktion geführt haben. Speichert man zusätzlich die zuletzt durchlaufenen Knoten und gibt diese aus, kann der Ablauf noch besser nachvollzogen und mögliche Fehlerquellen leichter identifiziert werden.

Die Implementation und das designen einer FSM ist einfach. Hauptsächlich werden Kenntnisse über endliche Automaten benötigt. Es gibt genügend Internet Quellen, welche eine FSM Implementation dokumentieren. Eine FSM wird auch häufig als Einführungsbeispiel in die Game-AI Entscheidungssysteme genommen, wie es in vielen Fachbüchern, wie \autocite{} zur Game-AI ersichtlich ist.

Eine Finite State Machine (FSM) wird häufig für einfache NPC-Logiken empfohlen, da ihr Design, die Implementierung, Visualisierung und das Debuggen vergleichsweise einfach sind. Doch mit der größe des Spieles steigt der Aufwand die FSM umzusetzen, da sie viel zu unskalierbar und undynamisch ist.\autocite{review_game_ai} Im Punkt der Skalierbarkeit ist sie GOAP unterlegen.\autocite{Schwab2021} Außerdem können Leistungsprobleme auftreten, insbesondere bei einer übermäßigen Anzahl von Zuständen.\autocite{U2023} Die Nachteile führten dazu, dass die Spielindustrie nach alternativen Methoden für die Entscheidungsfindung von NPCs suchte \autocite{U2023}. Ein Beispiel hierfür ist GOAP von Jeff Orkin, welcher mit GOAP einen neuen Ansatz entwickelte.

\section{Behavior Tree}

Wie auch die FSM ist der BT ein statisches Entscheidungssystem. Er ist jedoch im Vergleich zu FSM skalierbarer. Die Aktionen eines Behavior Tree sind durch die Tasks loser gekoppelt und müssen sich nicht gegenseitig stark beeinflussen. So kann bei einer Erweiterung ein neuer Zweig hinzugefügt werden mit seinen eigenen Tasks, ohne viele bestehende Aktionen oder Strukturen zu verändern.\autocite{aiag}  Allerdings kann auch ein BT mit zunehmender Anzahl an Aktionen unübersichtlich werden. Erfahrung zeigt, dass das Lesen und Verstehen eines Behavior Trees schwieriger ist als bei einer FSM. Wobei es Literaturen wie \autocite{} gibt die das Gegenteil behaupten.

Auch das Debuggen soll laut Quellen wie \autocite{aiag} und \autocite{review_game_ai} einfacher sein. Insbesondere durch die Tasks und ihre Rückgabewerte lässt sich nachvollziehen, welche Pfade im Baum durchlaufen wurden. Eine Visualisierung ist ebenfalls möglich und kann das Verständnis zusätzlich erleichtern.

Ein Vorteil im Gegensatz zur FSM ist, dass man komplexe Verhalten eines NPC einfacher designen kann \autocite{aiag}. Dafür hat der BT durch die verschiedenen Kategorien der Tasks eine höhere Komplexität, wodurch es aber erst möglich ist interessante NPC Verhalten zu entwickeln. Entwickler müssen viel Zeit darauf verwenden, passende Bedingungsknoten zu erstellen und sie mit den richtigen Verhaltensweisen zu verknüpfen \autocite{Schwab2021}. Kenntnisse in der Graphentheorie, insbesondere über \ref{gerichtete Graphen}, sind für das Verständnis eines BT von Vorteil.
 
Ein BT eignet sich gut für immersive NPC-Logiken. Allerdings ist er mit seinen verschiedenen Tasks schwieriger zu erlernen als eine FSM. Zudem wird der BT als Ad-hoc-Behavior-Authoring-System als zu statisch empfunden.\autocite{aiag}


\section{GOAP}

Das Entscheidungssystem GOAP ist hinsichtlich der Skalierbarkeit den zuvor beschriebenen Systemen überlegen. Es müssen bei neuen Aktionen oder Änderungen bestehender Aktionen keine manuellen Verknüpfungen getätigt werden, da alle Aktionen unabhängig voneinander existieren. Die Reihenfolge der Aktionsausführung wird dynamisch durch GOAP bestimmt, was es zu einem anpassungsfähigen Entscheidungssystem macht.

Ein Nachteil der mit dem dynamischen System kommt ist das Debuggen. Es ist es schwierig, die mögliche Reihenfolge der Aktionen vorherzusagen, da GOAP die Aktionen basierend auf ihren Kosten und Zuständen auswählt und nicht durch statische Verbindungen, wie es in Ad-hoc-Behavior-Authoring-System der Fall ist. Eine mögliche Lösung wäre eine Visualisierung des Suchbaums, wie er durch den A*-Algorithmus in GOAP generiert wird. Eine solche Darstellung würde aufzeigen, welche Aktionen potenziell in Frage kamen und welche letztendlich priorisiert wurden. Allerdings ist die Implementierung dieser Visualisierung deutlich komplexer als bei einer FSM oder einem BT.

Ein weiterer Nachteil der mit dem dynamischen System kommt ist die Komplexität der Funktionsweise. Die Implementierung ist somit anspruchsvoller als bei einer FSM oder einem BT und erfordert ein tiefgehendes Verständnis der Funktionsweise von GOAP. Hat man diese jedoch verstanden, können immersive NPC-Verhalten designed werden. Beim Designen von NPC-Verhalten ist insbesondere die Zuweisung der Kosten einer Aktion ist eine Herausforderung \autocite{Schwab2021}. Kenntnisse im Bereich von Graphentheorie und Suchalgorithmen können das Verständnis und die Nutzung von GOAP jedoch erheblich erleichtern.

Trotz dieser Herausforderungen ist GOAP ein leistungsstarkes Entscheidungssystem für immersive NPC-Verhaltensweisen. Allerdings geht die erhöhte Immersion mit einer komplexeren Implementierung, einem schwierigeren Verständnis und aufwendigerem Debuggen einher.

Die folgende Tabelle soll anhand Harveyballs die Entscheidungssysteme bewerten. Die Bewertung geht aus dem Vergleich und Benchmarks hervor. 

\begin{table}[ht]
  \caption{Tabellarische Bewertung}
  \label{tab:ES Vergleich Tabelle}
  \centering
  \begin{tabular}{lccc}
    \toprule
    & Finite State Machine & Behavior Tree & GOAP\\
    \midrule
		Erlernbarkeit & \harveyBallFull & \harveyBallThreeQuarter & \harveyBallHalf\\
    Implementation	& \harveyBallFull  & \harveyBallThreeQuarter  & \harveyBallHalf\\
		NPC-Design & \harveyBallQuarter & \harveyBallThreeQuarter & \harveyBallFull\\
    Skalierbarkeit	& \harveyBallQuarter & \harveyBallHalf & \harveyBallFull\\
    Debugging	& \harveyBallHalf & \harveyBallThreeQuarter & \harveyBallQuarter\\
		Performance & \harveyBallFull & \harveyBallThreeQuarter & \harveyBallHalf\\
		Speicherverbrauch & \harveyBallFull & \harveyBallThreeQuarter & \harveyBallHalf\\
    \bottomrule
  \end{tabular}
\end{table}

%\autocite{Schwab2021}:
%GOAP system in not ideal though. First of all, it is resource-heavy thus it is impossible to reliably implement full-scale system on mobile platform (as of 2018 at least). 
%Additionally, it is really hard to predict possible queue of actions which makes it hard to debug and a challenge to assign satisfying costs to every action.
%FSM is most definitely not a viable alternative to GOAP. As stated in 1, its maintenance in ever-changing game development environment is too much of a hassle with complicated AI behavior. It is however the perfect solution for small projects because of it simplicity.
%BT is not perfect solution for more complicated AIs though. Developers need to spend a lot of time to create appropriate conditional nodes and link them with correct behaviors.

\begin{figure}[h]
  \centering
  \includegraphics[width=16cm]{Vergleich/avg_fps}
	\captionsetup{justification=justified, format=plain}
  \caption{FPS-Performance Benchmark}
  \label{FPS-Performance Benchmark}
\end{figure}


%Zusammenfassung:
%- With recent technological developments, FSMs, DTs and BTs for managing decisions of NPCs are deficient in some situations, such as bad performance on overgrown tree structures, repeating mistakes without learning, and selecting the same decisions without being adaptive to different conditions creating the need for more believable character management methods

%Oleg: Man merkt, dass mit der komplexität und Funktionen immersivere NPC-Verhalten entwicklet werden können