\chapter{Entscheidungssysteme}

%Man unterscheidet zwischen open-loop und closed-loop Systemen. Bei nondeterministischen environments, also unversehbaren Umgebungen sollten closed-loop Systeme benutzt werden

Die Entscheidungsfindung ist die Entscheidung, welche Aktionen für einen NPC gewählt werden. Sie wird über sogenannte Entscheidungssysteme realisiert. Basierend auf dem Zustand des NPC, führen sie verschiedene Aktionen über Komponenten\ref{} durch. Nach dem Fund der jeweiligen Aktion gibt der Prozessor dem Entscheidungssystem Zeit, die dazugehörige Komponente auszuführen.

\section{Ad-Hoc Behavioring Authoring}

Zu den populärsten Entscheidungssystemen der Game-AI gehören die Ad-Hoc Behaviour Authoring Methoden. Zu diesen gehören die Finite State Machines (FSM) und Behavior Trees (BT). Die Ad-Hoc Behaviour Authoring Methoden dominieren die Entscheidungsfindung der NPCs in der Game-AI. Bei den Methoden wird die Verhaltensweise der NPCs explizit programmiert. Sie beinhalten normalerweise keine Art von Algorithmen zum Lernen oder Suchen von Entscheidungen. Sie sind leicht zu implementieren, visualisieren und debuggen. Mit der steigenden Komplexität der NPCs wird es jedoch schwieriger, das Entscheidungssystem zu designen, erweitern oder anzupassen.

\subsection{Finite State Machine}

Die Finite State Machine (FSM) wird als Graph repräsentiert. Die FSM speichert dabei Informationen in Knoten, die wiederum Kanten besitzen, die zu weiteren Knoten führen. Eine FSM kann sich zu jedem Zeitpunkt nur in einem Knoten befinden. Ein Knotenwechsel erfolgt, wenn die Bedingung für die entsprechende Kante erfüllt ist. 

In der Game-AI repräsentieren die Knoten die Zustände des NPC, wie zum Beispiel das Patrouillieren oder Angreifen. Die Zustände der Knoten werden über Komponenten\ref{} ausgeführt. So benötigt der Zustand des Patrouillierens solche Komponenten, die ihn zu bestimmten Punkten bewegen. Die Übergänge über die Kanten zwischen den Zuständen erfolgen über Bedingungen. So kann ein NPC vom Zustand des Patrouillierens in den des Angreifens wechseln, sobald die Bedingung erfüllt ist, dass der NPC den Spieler sieht. Die NPCs des FPS Half-Life wurde beispielsweise über eine FSM realisiert.

\begin{figure}[h]
  \centering
  \includegraphics[width=10cm]{Videospielentwicklung/FSM}
	\captionsetup{justification=justified, format=plain}
  \caption{Finite State Machine Beispiel an einem FPS-NPC}
  \label{FSM}
\end{figure}

\subsection{Behavior Tree}

Der Behavior Tree (BT) wird als Baumstruktur dargestellt. Anders als die FSM besitzt der BT keine Zustände, sondern Tasks. Diese Tasks lassen sich in verschiedene Kategorien einteilen und erhalten über den Prozessor Zeit, ihr Skript durchzuführen.

% Run, Success oder Failure groß klein?
Nach der Ausführung gibt das Skript des Tasks einen der folgenden Werte zurück: Run, Success oder Failure. Run impliziert, dass der Task noch aktiv ist, Success, dass der Task erfolgreich abgeschlossen wurde und Failure, dass der Task fehlgeschlagen ist.

Die Kategorien der Tasks lauten wie folgt: Conditions, Actions und Composites. Die Condition Task prüft Bedingungen, die einen Wert wie Success oder Failure zurückgibt, wie zum Beispiel, ob der Spieler zu sehen ist. Meistens findet die Ausführung der Condition Task vor der Action Task statt. Die Action Taks führt anschließend ihre Aktion über Komponenten des NPC durch, wie zum Beispiel zu schießen oder in Deckung zu gehen. Beide Task Kategorien sind die Blätter der Baumstruktur.

Die dritte Kategorie ist die Composite Task, welche die Sammlung der Child-Tasks, also der Condition- und Action-Tasks, verwaltet. Das Verhalten der Composite Task basiert auf dem resultierenden Wert der Child-Tasks. Die Composite Task lässt sich in zwei Subkategorien, Sequences und Selectors, aufteilen. Basierend auf dem Rückgabewert wird entschieden, ob der nächste Child-Task ausgeführt wird oder der Composite stoppt und selbst einen Rückgabewert zurückgibt. So gibt ein Selector den Rückgabewert Success, sobald einer seiner Child-Tasks Success zurückgibt. Sollte ein Child-Task dagegen Failure zurückgeben, so wird der nächste Child-Task ausgeführt, bis keine Child-Tasks verfügbar sind und der Selector folglich Failure an seinen Parent zurückgibt. So führen Selectors die erstmögliche Child-Task in ihrem Set aus. Eine Sequence gibt Failure als Rückgabewert, sobald einer seiner Child-Tasks Failure zurückgibt. Erst, wenn alle Child-Tasks Success zurückgeben, gibt die Sequence den Rückgabewert Success zurück. Eine Sequence repräsentiert ein Set an Aktionen, die durchgeführt werden müssen. Ein Beispiel für die Umsetzung des BT als Entscheidungssystem für NPCs ist der FPS Halo 2.

\begin{figure}[h]
  \centering
  \includegraphics[width=15cm]{Videospielentwicklung/BT}
	\captionsetup{justification=justified, format=plain}
  \caption{Behavior Tree Beispiel an einem FPS-NPC}
  \label{BT}
\end{figure}

%Andrere Quellen
 Oneachupdate, aBTperformsadepth-first traversaluntil a lowlevelbehaviour (representedbya leafnode)has either succeeded or is set to the" running" state. \autocite{qlbt}

\section{Suchalgorithmen}

% Ändern
Aufgaben der AI können auch als Suchprobleme formuliert werden, die durch das Finden des besten Pfades gelöst werden. Die Suchalgorithmen konstruieren einen Suchbaum, bei dem der Wurzelknoten den Ausgangszustand darstellt, die Kanten die Operationen des Agenten repräsentieren, die zu einem neuen Knoten führen, welcher einen neuen Zustand repräsentiert. Aus einem Zustand sind mehrere Operationen möglich. Einer der bekannteren Suchalgorithmen ist der Monte Carlo Tree Search (MCTS), welcher Bestandteil von AlphaGo ist. Ein weiterer bekannter Suchalgorithmus ist A*, welcher sowohl die Navigation der NPC als auch die Entscheidungsfindung in GOAP realisiert.

\section{Entscheidungssysteme in der Robotik}

\subsection{Finite State Machine}

Bei der Entwicklung eines Roboter-Verhaltens wird darauf geachtet, dass die vielen Komponenten, die für das Verhalten nötig sind, möglichst effizient zusammenarbeiten. Eine der simpelsten Architekturen für die Umsetzung eines Roboter Verhaltens ist die Finite State Machine (FSM).

Ein Beispiel ist ein Linien-Folgender-Roboter, der mithilfe von FSM umsetzbar ist. Die FSM bestimmt die Aktion auf Basis des aktuellen Knotens des Roboters. Der Roboter kann seinen Knoten und damit seine Aktion wechseln. Wenn ein Sensor des Roboters beispielsweise erkennt, dass er sich nicht mehr innerhalb der schwarzen Linie bewegt, dann wechselt er in einen anderen Knoten, der durch seine Aktionen den Kurs des Roboters korrigiert.

\subsection{Behavior Tree}

Der Behavior Tree (BT) ist ein weiteres Entscheidungssystem in der Robotik und stammt ursprünglich aus der Spielentwicklung \ref{}. Wie auch die FSM, wird der BT für die Aufgabenorchestrierung eines Roboters eingesetzt. Im Vergleich zu der FSM ist der BT zwar komplexer umzusetzen, hat aber folgende Vorteile: Aktionen können im BT leichter wiederverwendet und erweitert werden. Zudem muss der BT nicht definieren, wie eine Aktion im Bezug zu einer nachfolgenden Aktion steht.

Ein Konzept für die Nutzung eines BT in der Robotik ist die Umsetzung auf einem unbemannten Luftfahrzeug (UAV). Dabei kann der BT als Controller für einen Luftkampf dienen.

\subsection{Stanford Research Institute Problem Solver (STRIPS)}

Zu dem Entscheidungssystem Goal Oriented Action Planner (GOAP) gibt es wenige Studien in dem Bereich der Robotik. Daraus lässt sich schließen, dass der GOAP eine untergeordnete Rolle in der Robotik spielt. Der GOAP basiert auf dem älteren Entscheidungssystem Stanford Research Institute Problem Solver (STRIPS), der wiederum im Roboter Shakey eingesetzt wurde.

Der STRIPS wurde erstmals für den mobilen Roboter mit dem Nicknamen Shakey als Plansystem für die Aktionen implementiert. Dieser Roboter wurde von 1966 bis 1972 als wissenschaftliches Projekt im Labor für künstliche Intelligenz des Stanford Research Institutes entwickelt. Das Ziel dieses Projekts war es, Konzepte und Techniken der künstlichen Intelligenz zu entwickeln. Diese Konzepte sollen Automaten ermöglichen, in realistischen Umgebungen unabhängig zu agieren. Insbesondere boten sie den Kontext und die Motivation für die Entwicklung des A*-Suchalgorithmus\autocite{}. Der Roboter konnte nach seiner Fertigstellung in Räumen fahren, Hindernisse und Änderungen in der Umgebung erkennen sowie Boxen verschieben. Gab man dem Roboter ein Ziel als logische-Formel, so sollte der STRIPS eine gültige Sequenz an solchen Aktionen zurückgeben, die nach ihrer Ausführung das Ziel erreichen sollen.

Der STRIPS besteht aus den folgenden Komponenten: Einen Ausgangszustand, gegebenen Zielzustand und eine Sammlung an Aktionen.

Der Ausgangszustand repräsentiert das derzeitige Wissen über die Welt des Agenten, also seinen Status. Im Falle von Shakey könne es sich um die Position handeln, in der sich der Roboter befindet und das Wissen über seine Umwelt, wie zum Beispiel die Verbindung der Räume.

Die Aktionen haben Effekte und Vorbedingungen. Die Vorbedingungen einer Aktion entscheiden, ob es möglich ist, diese in die Sequenz aufzunehmen. Die Effekte werden über eine Add- und Delete-List realisiert. Während die Delete-List Wissen über Zustände löscht, fügt die Add-List neues Wissen über Zustände hinzu. Durch die Durchführung der Add- und Delete-List werden Zustände, wie der Ausgangszustand, geändert.

Der Zielzustand wurde im Falle von Shakey durch die logische-Formel von dem Benutzer gegeben. STRIPS baut aus dem Ausgangszustand eine Sequenz an Aktionen, die daraufhin in ihrer Reihenfolge ausgeführt werden. Die Ausführung der Aktionen und ihrer Effekte soll den Ausgangszustand so verändern, dass der Agent zu seinem Zielzustand kommt.

Um eine Sequenz an Aktionen zu erzeugen, muss STRIPS die Effekte und Vorbedingungen seiner Aktionen kennen. Hierfür prüft STRIPS, ob der Zielzustand bereits durch den Ausgangszustand erfüllt ist. Sollte der Zielzustand nicht erfüllt sein, wählt STRIPS eine Aktion aus, deren Effekte den Zielzustand am ehesten erreichen können. Dabei wird nach einer Aktion gesucht, deren Add- und Delete-Listen dazu beitragen können, den Zielzustand zu erreichen. Sollte die relevante Aktion nicht erfüllte Vorbedingungen durch das derzeitige Zustandsmodell besitzen, werden die Vorbedingungen als Unterziel hinzugefügt und müssen ebenfalls durch andere Aktionen erfüllt werden. Wenn mehrere relevante Aktionen gefunden werden, dann führt dies zu einem Suchbaum. Der Prozess wird so lange wiederholt, bis alle Unterziele erfüllt sind. Sobald die Unterziele erfüllt sind, wird das Ausgangsmodell basierend auf der Add- und Delete-List der Aktionen in ein neues Zustandsmodell transformiert. Dieses neue Zustandsmodell repräsentiert eine hypothetische Welt, die durch die Anwendung der ausgewählten Aktion entsteht. Es wird als neuer Ausgangspunkt für die nächste Selektion einer Aktion verwendet, um den Zielzustand schrittweise zu erreichen. Sollte der neue Ausgangspunkt nicht dem Zielzustand entsprechen, wird der Prozess fortgesetzt. Entspricht der Ausgangspunkt schließlich dem Zielzustand, so wurde ein Plan an Aktionen gefunden. 
