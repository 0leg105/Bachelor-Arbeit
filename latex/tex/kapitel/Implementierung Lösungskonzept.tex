\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{Godot}{
	keywords={class_name, func, for, return, in range, is, var, not, continue, or},
	morecomment=[l]{#}
}

\lstdefinelanguage{Pseudo}{
	keywords={FUNCTION, IMPORT, END if, then, void},
	morecomment=[l]{//}
}

\lstdefinelanguage{dict}{
	keywords={class_name, func, for, return, in range, is, var, not, continue},
}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}


\chapter{Implementierung des Lösungskonzepts}
\label{chap:implementierung lk}

Die praktische Umsetzung des GOAP Systems wird nun in diesem Kapitel beschrieben. Es soll insbesondere auf die Umsetzung des GOAP-Entscheidungssystem eingegangen werden. Zunächst wird die grundlegende Architektur von GOAP mit ihren Modulen erläutert, gefolgt von einer Darstellung des Szenarios, in dem die Entscheidungssysteme implementiert werden. Abschlie\ss{}end wird die Realisierung der Benchmarks behandelt.

So soll die Grundlegende GOAP Architektur anhand von UML-Notation dargestellt und beschrieben werden. Sie bildet die Grundlage für die Implementation des Entscheidungssystems im Szenario. Mithilfe von Pseudocode werden die in den UML-Klassendiagrammen dargestellten Methoden und Attribute weiter erläutert. Die Architektur basiert dabei auf den Grundlagen der GOAP Kapitel \ref{chap:goap}, wissenschaftlicher Literatur zum Thema GOAP und der F.E.A.R SDK\autocite{}.

\section{GOAP Architektur}
\label{chap:goap architektur}

Aus dem GOAP-Kapitel \ref{chap:goap} geht hervor, dass ein GOAP-System aus einem Planner, GOAP-Zielen, GOAP-Aktionen und einer FSM besteht. Diese Module sollen ihre Aufgaben erfüllen, wie im Grundlagenkapitel zu GOAP beschrieben. Dafür müssen diese Module in einer Architektur zusammenarbeiten. Die grundlegende Architektur von GOAP wird in Abbildung \ref{fig:GOAP Architektur} dargestellt.

Der Agent wird über eine \textit{GoapAgent} Klasse realisiert. Sie soll in der Architektur die Hauptklasse darstellen und als Schnittstelle zur restlichen Spielwelt fungieren. Die Spielwelt benötigt nämlich eine Schnittstelle, um dem NPC Informationen zu übergeben, wie beispielsweise bestimmte Koordinaten zum erfüllen bestimmter Aktionen. Die zentrale Aufgabe des \textit{GoapAgent} ist nämlich die Aktionen einer Aktions-Sequenz ausführen. Für die Ausführung der eigentlichen Aktionen werden dabei Komponenten benötigt, welche die Spielwelt manipulieren können. Die Klasse \textit{Npc} (Abbildung \ref{fig:GOAP Architektur} und \ref{fig:npc class}) stellt diese Komponenten bereit. Ein Beispiel einer solchen Komponente ist die \textit{Vision-Component}, die es dem NPC ermöglicht den Spieler zu erfassen. Komponenten werden in Kapitel \ref{chap:komponenten} erläutert.

Der \textit{StateManager} verwaltet die Zustände des NPC, die von \textit{GoapAction} und \textit{GoapGoal} abgefragt werden. Diese Zustände können über die Komponenten der Oberklasse \textit{Npc} oder durch nichtdeterministische Umstände der Spielwelt verändert werden. Ein Beispiel für einen Zustand der im \textit{StateManager} verwaltet wird, ist die Sichtbarkeit der Spielfigur, die durch die \textit{Vision-Component} beeinflusst wird.

Für die Generierung von Aktions-Sequenzen des \textit{GoapAgent} ist die Klasse \textit{GoapPlanner} zuständig. Wie in der Architektur dargestellt, besitzt der \textit{GoapPlanner} Objekte der Klassen \textit{GoapGoal}, \textit{GoapAction} und \textit{AStarNode}, welche dazu benötigt werden eine Aktions-Sequenz zu finden. Aus den \textit{GoapGoal} Objekten wählt der \textit{GoapPlanner} einen Zielzustand aus, für den eine Aktions-Sequenz gesucht wird. Der \textit{GoapPlanner} sucht die Aktions-Sequenz mithilfe des A$^*$ Algorithmus\ref{}. Die Klasse \textit{AStarNode} wird zur Generierung von Knoten für den Suchbaum des A$^*$ Algorithmus benötigt. Ein \textit{AStarNode} setzt dabei die Eigenschaften eines Suchbaum-Knoten um, wie in Kapitel \ref{chap:knoten eines suchbaums} beschrieben.

Die Klasse \textit{GoapAction} stellt die Basisklasse für GOAP-Aktionen dar. Eine GOAP-Aktion repräsentiert dabei eine Kante im Suchbaum, siehe Kapitel \ref{chap:goap actions}.

Es wird keine FSM in der Architektur umgesetzt, da die Implementation keine Animationen umfasst. Stattdessen geschieht die Ausführung der Aktionen direkt innerhalb der Klasse \textit{GoapAgent}. Sollten Animationen vorhanden sein, können diese auch über die Klasse \textit{GoapAction} ausgeführt werden. Es besteht keine zwingende Notwendigkeit, eine FSM innerhalb von GOAP umzusetzen. Ein Konzept für die Implementierung einer FSM wäre es, diese an den \textit{GoapAgent} oder \textit{GoapPlanner} zu koppeln und die Aktions-Sequenz von dort aus auszuführen. Die Aktionen würden dann auch die Knotenwechsel für die FSM durchführen.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth, trim=20 20 20 20]{Implementation/goap arc.pdf}
	\captionsetup{justification=justified, format=plain}
  \caption{GOAP Architektur}
  \label{fig:GOAP Architektur}
\end{figure}




\subsection{\textit{GoapAgent}}
\label{chap:goapagent uml}

Die Abbildung \ref{fig:GoapAgent} stellt die Klasse \textit{GoapAgent}, mit ihren Klassenattribute und Methoden dar.

Der \textit{goap\_planner} ist eine Referenz auf die Klasse \textit{GoapPlanner}, welcher die \textit{action\_sequence} des \textit{GoapAgent} bestimmt. Das Array \textit{action\_sequence} speichert Objekte vom Typ der Klasse \textit{GoapAction}. Sie stellt die ermittelte Aktions-Sequenz durch den A*-Algorithmus dar. Die Integer-Klassenvaraible \textit{current\_step} handelt als Indexzeiger, welcher auf die aktuell auszuführende Aktion des \textit{action\_sequence} verweist.

% Goap Agent
\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{Lösungskonzept/agent.pdf}
	\captionsetup{justification=justified, format=plain}
  \caption{GoapAgent}
  \label{fig:GoapAgent}
\end{figure}


Die update Methode ruft Methoden der Klassen und Komponenten innerhalb des NPC auf. Sie wird wiederum durch eine \textit{\_process} Funktion jedes \textit{Frame} aufgerufen, um kontinuierliche Logik wie Bewegungen oder Raycasting des \textit{GoapAgent} zu verarbeiten. Diese wird wiederum über die Komponente aufgerufen, die das Objekt \textit{GoapAgent} instanziiert. Der Parameter \textit{delta} repräsentiert die Zeit seit dem letzten \textit{Frame} und könnte an andere Methoden übergeben werden.

% update Methode
%\lstinputlisting[firstline=0, language=Pseudo, linerange={1-7}, caption={update Methode des \textit{GoapAgent}}, label=lst:caption]{code/goap agent.txt}

\begin{lstlisting}[language=Pseudo, caption={update Methode des \textit{GoapAgent}}, mathescape=true]
FUNKTION update(delta) $\rightarrow$ void
    WENN goap_planner neue action_sequence gefunden hat DANN
        current_step $\leftarrow$ 0
        action_sequence $\leftarrow$ goap_planner.get_current_sequence()
    ENDE WENN
    follow_sequence(delta)
ENDE update()
\end{lstlisting}

In der update Methode werden Abfragen gestellt, ob der \textit{goap\_planner} eine neue \textit{action\_sequence} generiert hat. Wurde eine neue \textit{action\_sequence} generiert, so wird die Objektvariable \textit{current\_step} auf $0$ zurückgesetzt und die neue \textit{action\_sequence} aus dem \textit{goap\_planner} abgerufen. Die \textit{action\_sequence} wird darauf durch die Methode \textit{follow\_sequence} ausgeführt werden.

% follow_sequence Methode
\"{U}ber die Methode \textit{follow\_sequence} geschieht die eigentliche Ausführung der Aktionen aus der \textit{action\_sequence}. Sollte \textit{action\_sequence} leer sein, bereits ausgeführt worden oder ungültig sein, so wird eine neue \textit{action\_sequence} von dem \textit{goap\_planner} gefordert werden. Ansonsten wird mithilfe des \textit{current\_step} Index die jeweilige Aktion über ihre \textit{GoapAction} \textit{update} Methode ausgeführt werden. Bei erfolgreicher Ausführung der Aktion wird der \textit{current\_step} inkrementiert, um auf die nächste Aktion der \textit{action\_seqeunce} zugreifen zu können.

\begin{lstlisting}[language=Pseudo, caption={\textit{follow\_sequence} Methode des \textit{GoapAgent}}, mathescape=true]
FUNKTION follow_sequence(delta) : void
	WENN action_sequence leer ODER action_sequence durchgegangen ODER action_sequence[current_step] DANN
		goap_planner.set_create_sequence(WAHR)
		ENDE FUNKTION
	ENDE WENN
	WENN action_sequence[current_step].update(delta) ausgeführt DANN
		current_step um 1 erhöhen
	ENDE WENN
ENDE FUNKTION
\end{lstlisting}







\subsection{\textit{GoapPlanner}}
\label{chap:goapplanner uml}


\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth, trim=20 20 20 20]{Lösungskonzept/planner.pdf}
	\captionsetup{justification=justified, format=plain}
  \caption{GoapPlanner}
  \label{fig:goapplanner uml}
\end{figure}

Die Abbildung \ref{fig:goapplanner uml} zeigt den Aufbau des \textit{GoapPlanner}. Der \textit{GoapPlanner} arbeitet mit Zielen und Aktionen, welche durch die Arrays \textit{actions} und \textit{goals} gegeben werden. \"{U}ber \textit{current\_goal} wird das Ziel gespeichert, zu dem eine \textit{action\_sequence} gesucht wird. Die \textit{action\_sequence} ist die generierte Aktions-Sequenz durch den \textit{GoapPlanner} und wird in einem Array mit \textit{GoapAction} als Elementtyp gespeichert. Das \textit{current\_state} Dictionary speichert den derzeitigen Zustand des NPC. Die Initialisierung des \textit{current\_state} findet über den \textit{state\_manager} Parameter statt, welcher über die \textit{update} Methode übergeben wird. Das \textit{create\_sequence} Attribut informiert den \textit{GoapPlanner} darüber, ob eine neue \textit{action\_sequence} generiert werden soll. Das \textit{effect\_action\_dict} Dictionary speichert alle Zustände als \textit{key} und die Aktionen, welche den Zustand beeinflussen können als \textit{values}. So erhält man eine schnellere Zugriffszeit, als wenn man jeden Effekt einer Aktion im Array mit dem benötigten Zustand vergleicht. \"{A}hnlich zur Tabelle, wie im GOAP Grundlagenkapitel \ref{}.

% update
Die \textit{GoapPlanner} Methode update wird über die update Methode des \textit{GoapAgent} aufgerufen. Hierbei werden Methoden und Abfragen durchgeführt, welche die current\_goal und die dazugehörige action\_sequence bestimmen. 

Für die Bestimmung des current\_goal ist die Methode get\_best\_goal verantwortlich. \"{A}ndert sich das Ziel während der Laufzeit oder wird über create\_sequence eine action\_sequence angefragt, so soll eine neue action\_sequence generiert werden. Die Suche geschieht über die Methode create\_new\_sequence. 

\begin{lstlisting}[language=Pseudo, caption={update Methode des \textit{GoapAgent}}, mathescape=true]
FUNKTION update(state_manager: StateManager) $\rightarrow$ bool
    current_state $\leftarrow$ state_manager.get_current_state()
    new_goal $\leftarrow$ get_best_goal()
    WENN current_goal NICHT new_goal entspricht ODER create_sequence WAHR IST DANN
        current_goal $\leftarrow$ new_goal
        action_sequence $\leftarrow$ create_new_sequence()
        root_node Speicher freigeben
        ZUR\"{U}CKGEBEN WAHR
    ENDE WENN
    ZUR\"{U}CKGEBEN FALSCH
ENDE FUNKTION
\end{lstlisting}

% create_new_sequence Methode
Die Methode create\_new\_sequence leitet die Generierung einer action\_sequence ein. Dafür muss ein Wurzelknoten des Typen \textit{AStarNode} erstellt werden, welcher dem a\_star\_algorithm übergeben wird. Für den Wurzelknoten wird ein Dictionary über die Methode create\_current\_state\_of\_goals instanziiert, in dem die Werte der Zielzustände des current\_goal basierend auf den Werten des \textit{current\_state} des Agenten überschrieben werden. Das Dictionary wird als Zustand des Wurzelknoten dienen, mit dem die a\_star\_algorithm Methode nach der Aktions-Sequenz sucht. Die Funktionsweise der a\_star\_algorithm Methode wird im Pseudocode beschrieben. Sie sucht nach den Regeln der Bestensuche\ref{}.

% PriorityQueue
Die open\_list wird über eine PriorityQueue realisiert. Man beachte, dass Godot 4.3 keine PriorityQueue besitzt und man diese selbst implementieren müsste. Eine PriorityQueue speichert Knoten, sortierter nach ihren $f(n)$ Kosten, sodass Knoten mit den niedrigsten Kosten bevorzugt abgerufen werden. 

% expand_node Methode
Die expand\_node Methode fügt Kindknoten child\_node des expandierten Knoten expanded\_node in die open\_list, welche vorher von A$^*$ gewählt wurde. Es folgt die Instanziierung der Kosten $g(n)$, $h(n)$ und $f(n)$ des child\_node. Abschlie\ss{}end wird der child\_node in die \textit{open\_list} hinzugefügt.

% get_child_nodes Methode
Die get\_child\_nodes Methode sucht nach Kanten (Aktionen) welche die benötigten Zustände des Knoten erfüllen können. Dabei werden die benötigten Zustände mit den Zuständen der \textit{effect\_action\_dict} verglichen.

Wird eine Aktion gefunden, welche den Zustand erfüllt, so wird untersucht ob der Effekt, der Aktion den Zustand umsetzen kann. Erfüllt der Effekt den gewünschten Zustand, so wird ein Kindknoten erstellt. Dieser Kindknoten speichert die Kante (Aktion) die zu dem Knoten geführt hat, sowie den Effekt auf den \textit{current\_state}. Die restlichen Inhalte des Knoten werden in der zuvor beschriebenen expand\_node Methode instanziiert.

% create_path Methode
Wenn a\_star\_algorithm einen expand\_node expandiert und dieser keine zu erfüllenden Zustände mehr besitzt, wurde der optimale Pfad gefunden. Um nun die korrekte action\_sequence zu erhalten, müssen die Aktionen vom expand\_node rekursiv zum Wurzelknoten zurückverfolgt werden. Dies wird mithilfe einer \textit{create\_path} Methode durchgeführt.

\begin{lstlisting}[language=Pseudo, caption={update Methode des \textit{GoapAgent}}, mathescape=true]
FUNKTION a_star_algorithm(root_node) $\rightarrow$ action_sequence
	open_list $\leftarrow$ PriorityQueue
	closed_list $\leftarrow$ Dictionary
	open_list.push(root_node)
	SOLANGE open_list NICHT leer
		expanded_node $\leftarrow$ open_list.pop()
		WENN expanded_node.is_satisfied() DANN
			open_list Speicher freigeben
			ZUR\"{U}CKGEBEN create_path(expanded_node)
		ENDE WENN
		expanded_node in closed_list hinzufügen
		expand_node(expanded_node, open_list, closed_list)
	ENDE SOLANGE
	open_list Speicher freigeben
	ZUR\"{U}CKGEBEN []
ENDE FUNKTION

FUNKTION expand_node(expanded_node, open_list, closed_list) $\rightarrow$ void
	F\"{U}R JEDES child_node IN get_child_nodes(expanded_node)
		WENN child_node IN closed_list DANN
			FORTSETZEN
		ENDE WENN
		child_node_g_cost $\leftarrow$ expanded_node.get_g_score() + child_node.get_action().get_cost()
		WENN open_list.has(child_node) UND child_node_g_cost $\geq$ child_node.get_g_score() DANN
			FORTSETZEN
		ENDE WENN
		child_node_h_cost $\leftarrow$ child_node.get_unsatisfied_states().size()
		child_node_f_cost $\leftarrow$ child_node_g_cost + child_node_h_cost
		child_node.set_g_cost(child_node_g_cost)
		child_node.set_f_cost(child_node_f_cost)
		open_list.push(child_node)
	ENDE F\"{U}R
ENDE FUNKTION
\end{lstlisting}

\subsection{\textit{AStarNode}}
\label{chap:astarnode uml}

Der \textit{AStarNode} hat die Funktionsweise eines Knoten in einem Suchbaum. Abbildung \ref{fig:AStarNode} zeigt die Struktur der Klasse \textit{AStarNode} in der UML-Notation.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.9\textwidth, trim=20 20 20 20]{Lösungskonzept/astarnode.pdf}
	\captionsetup{justification=justified, format=plain}
  \caption{AStarNode}
  \label{fig:AStarNode}
\end{figure}


Ein \textit{AStarNode} speichert die Informationen des Suchproblems. Darunter die bis dahin erfüllten Zustände des Elternknoten parent\_node im Attribut \textit{current\_state}\_of\_goals, sowie alle Zielzustände die bis zu dem Knoten benötigt wurden im Attribut goal\_state. \"{U}ber das Klassenattribut parent\_node kann die create\_path Methode des \textit{GoapPlanner} rekursiv auf die Aktionen action des Typs \textit{GoapAction} zurückschlie\ss{}en. Die Kosten $f(n)$ werden unter f\_cost und $g(n)$ -Kosten unter g\_cost gespeichert.


Durch den Godot Konstruktor \_init wird ein \textit{AStarNode} mit seinen Attributen instanziiert. Die Berechnung der Kosten passiert durch die \textit{GoapPlanner} Methode expand\_node. Dort werden über die setter- Methoden des \textit{AStarNode} set\_g\_cost und set\_f\_cost initialisiert. \"{U}ber die Methode get\_unsatasfied\_states werden alle Zustände zurückgegeben, welche noch nicht erreicht wurden. Die Grö\ss{}e des Arrays welches von get\_unsatasfied\_states gegeben wird repräsentiert die heuristischen Kosten $f(n)$ der Aktion. Die Heuristik Kosten werden ebenfalls in der expand\_node Methode des \textit{GoapPlanner} berechnet und initialisiert.

Wird eine action gewählt, so wird ein \textit{AStarNode} mit den dazugehörigen Zuständen \textit{current\_state}\_of\_goals und goal\_states generiert werden. Die Generierung des neuen \textit{AStarNode} geschieht über die apply\_action\_to\_state Methode. Die Methode wird vom \textit{GoapPlanner} durch die Methode get\_child\_nodes auf dem expanded\_node aufgerufen. Dabei wird die action und der \textit{current\_state} als Parameter übergeben. Basierend auf den Parameter initialisiert die Methode, die Attribute goal\_states und \textit{current\_state}\_of\_goals für den neuen Knoten. Au\ss{}erdem initialisiert sie den zu expandierten Knoten als parent\_node sowie die Aktion als action.

Die Prüfung ob die Zustände eines expanded\_node erfüllt wurden, wird durch is\_satasfied geprüft. Dazu schaut die Methode ob das Array welches über die Methode get\_unsatasfied\_states zurückgegeben wird leer ist. Sollte das Array leer sein, so gibt es keine zu erfüllenden Zustände und der \textit{AStarNode} ist der Zielknoten.


\subsection{GoapGoal}
\label{chap:goapgoal uml}

Ein GoapGoal repräsentiert ein Ziel. Der \textit{GoapPlanner} bewertet die verfügbaren Ziele, vergleicht sie miteinander und wählt eines aus, basierend auf deren Gültigkeit und Priorität. Der Zielzustand des jeweiligen GoapGoal wird als Ausgangszustand für Suche genutzt. Die Klasse GoapGoal wird in der folgenden Abbildung mittels UML-Notation dargestellt.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.5\textwidth, trim=20 20 20 20]{Lösungskonzept/goal.pdf}
	\captionsetup{justification=justified, format=plain}
  \caption{GoapGoal}
  \label{fig:GoapGoal}
\end{figure}

Die Priorität und Gültigkeit wird aus dem Klassenattribut state\_manager abgeleitet. Die get\_best\_goal des \textit{GoapPlanner} benötigt die Gültigkeit und Priorität, um in folge dessen das Ziel auszuwählen. Die Abfragen geschehen durch die Methoden get\_priority und is\_valid. Ein Ziel wird erst dann berücksichtigt, wenn es durch die Methode is\_valid als gültig bestätigt wurde. Anschlie\ss{}end kann dessen Priorität mithilfe von get\_priority ermittelt werden. 

\"{U}ber die Methode get\_desired\_state werden die Zielzustände aufgerufen, welche der \textit{GoapPlanner} zur Suche der action\_sequence benötigt. 

Die Methode get\_goal\_name gibt den Klassennamen des GoapGoal zurück, welche von Debug Methoden genutzt werden kann.


%FORTSETZUNG
\subsection{GoapAction}
\label{chap:goapaction uml}

Ein Aktion des Typs \textit{GoapAction}, repräsentieren die Kanten eines Suchbaums. Sie besitzen Daten zur Generierung eines neuen Knoten. Folgende Abbildung stellt die \textit{GoapAction} Klasse nach UML-Notation dar.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth, trim=20 20 20 20]{Lösungskonzept/action.pdf}
	\captionsetup{justification=justified, format=plain}
  \caption{GoapAction}
  \label{fig:GoapAction}
\end{figure}

Mit Hilfe der Klassenattribute character\_body und state\_manager werden die Kosten $g(n)$ und die Gültigkeit der Aktion gelesen. Die Kosten $g(n)$ werden dabei über die get\_cost Methode berechnet.

Die Gültigkeit einer Aktion soll die Durchführbarkeit wiedergeben. Der \textit{GoapPlanner} wählt nur Aktionen aus, welche im derzeitigen Zustand des NPC durchführbar sind. Die Gültigkeit der Aktionen wird auch vor der Ausführung der update Methode jeweiligen Aktion durch den \textit{GoapAgent} geprüft, da die Aktion zu einer Zeit ausgeführt werden kann in der sich der Zustand des NPC wieder ändern kann und somit auch die Gültigkeit. Für die Rückgabe der Gültigkeit ist die is\_valid Methode zuständig.

Eine get\_preconditions Methode gibt die vorausgesetzten Zustände zurück, welche von anderen Aktionen erfüllt werden müssten. Ob eine Aktion einen Zustand erfüllen kann, hängt von der get\_effects Methode ab, welche ein \textit{Dictionary} mit dem Zustand und dessen Wert zurückgibt. Stimmt der Wert des Zustands mit dem Zielzustand überein, dann erfüllt die Aktion den Zustand.

Die update Methode leitet die eigentliche Ausführung der Aktion ein und wird über den \textit{GoapAgent} gestartet. Die Hoffnung dabei ist, dass die Aktion den erwünschten Wert des Effekts umsetzt. Aufgrund der nicht-deterministischen Natur der Spielwelt kann es jedoch vorkommen, dass der angestrebte Effekt nicht erreicht wird. Wird der Effekt nicht erreicht, so wird eine neue Sequenz angefordert oder das Ziel ändert sich bis dahin. Die Ausführung der Aktion wird dabei über \hyperref[chap:game-objects]{Komponenten} der Klasse Npc umgesetzt. Die Methode get\_action\_name gibt den Klassennamen der \textit{GoapAction} zurück.


\section{Umsetzung des Szenario}
\label{chap:implementierung szenario}

Die Benchmarks benötigen eine Umgebung auf der die NPCs mit ihren jeweiligen Entscheidungssystemen getestet werden. Zu diesem Zweck agieren die NPCs\ref{} in einer 2D kartierbaren Spielwelt, die in der Abbildung \ref{} dargestellt wird. Die NPC-Klassen unterscheiden sich in ihren Entscheidungssystemen, die Komponenten, die für eine Ausführung einer Aktion benötigt werden bleiben für alle NPC Klassen identisch und werden mit der Oberklasse Npc vererbt. Bei den Komponenten handelt es sich um: Vision-, Health-, Hit-, Melee-, Shoot-, Neighbor-, Move, LookAt-, Patrol-, Cover-, Vision- und PlayerBlock-Component. Sie ändern dabei die Zustände des StateManger, die in der GOAP Architektur erläutert wird\ref{}.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth, trim=20 20 20 20]{Implementation/npc class.pdf}
	\captionsetup{justification=justified, format=plain}
  \caption{Vererbung der Npc Klasse}
  \label{fig:npc class}
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth, trim=20 20 20 20]{Implementation/ego shooter.pdf}
	\captionsetup{justification=justified, format=plain}
  \caption{Ego-Perspektive des Spieler und Spielwelt}
  \label{fig:ego shooter}
\end{figure}

Der Performance-Benchmark\ref{fig:bps benchmark}, speichert während der Ausführung die Häufigkeit der Bilder-Pro-Sekunde für die jeweilige Anzahl an NPCs im gesamten Szenario. Der Benchmark beginnt mit einem NPC und wächst kontinuierlich, wobei alle 30 Sekunden ein neuer NPC der jeweiligen Klasse in die Spielwelt instanziiert wird. Für jede NPC-Klasse wird der Benchmark dreimal ausgeführt. Abschlie\ss{}end wird aus den gesammelten Daten der durchschnittliche FPS-Wert für jede NPC-Anzahl berechnet.

Der Speicher-Benchmark\ref{fig:mem benchmark}, gibt den Speicherverbrauch des gesamten Szenario. Auch dieser Benchmark beginnt mit einem NPC und wächst kontinuierlich, wobei alle 10 Sekunden ein neuer NPC der jeweiligen Klasse in die Spielwelt instanziiert wird. Für jede NPC-Klasse wird der Benchmark einmal ausgeführt. Abschlie\ss{}end wird auch hier aus den gesammelten Daten der durchschnittliche Speicherverbrauch für jede NPC-Anzahl berechnet.
